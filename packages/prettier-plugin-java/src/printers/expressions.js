"use strict";
/* eslint-disable no-unused-vars */

class ExpressionsPrettierVisitor {
  constantExpression(ctx) {}

  expression(ctx) {}

  lambdaExpression(ctx) {}

  lambdaParameters(ctx) {}

  lambdaParametersWithBraces(ctx) {}

  lambdaParameterList(ctx) {}

  inferredLambdaParameterList(ctx) {}

  explicitLambdaParameterList(ctx) {}

  lambdaParameter(ctx) {}

  regularLambdaParameter(ctx) {}

  lambdaParameterType(ctx) {}

  lambdaBody(ctx) {}

  ternaryExpression(ctx) {}

  binaryExpression(ctx) {}

  unaryExpression(ctx) {}

  unaryExpressionNotPlusMinus(ctx) {}

  primary(ctx) {}

  primaryPrefix(ctx) {}

  primarySuffix(ctx) {}

  fqnOrRefType(ctx) {}

  fqnOrRefTypePart(ctx) {}

  fqnOrRefTypePart$methodTypeArguments(ctx) {}

  fqnOrRefTypePart$classTypeArguments(ctx) {}

  parenthesisExpression(ctx) {}

  castExpression(ctx) {}

  primitiveCastExpression(ctx) {}

  referenceTypeCastExpression(ctx) {}

  newExpression(ctx) {}

  unqualifiedClassInstanceCreationExpression(ctx) {}

  classOrInterfaceTypeToInstantiate(ctx) {}

  typeArgumentsOrDiamond(ctx) {}

  diamond(ctx) {}

  methodInvocationSuffix(ctx) {}

  argumentList(ctx) {}

  arrayCreationExpression(ctx) {}

  arrayCreationDefaultInitSuffix(ctx) {}

  arrayCreationExplicitInitSuffix(ctx) {}

  dimExprs(ctx) {}

  dimExpr(ctx) {}

  classLiteralSuffix(ctx) {}

  arrayAccessSuffix(ctx) {}

  methodReferenceSuffix(ctx) {}

  identifyNewExpressionType(ctx) {}

  isLambdaExpression(ctx) {}

  isCastExpression(ctx) {}

  isPrimitiveCastExpression(ctx) {}

  isReferenceTypeCastExpression(ctx) {}

  isRefTypeInMethodRef(ctx) {}
}

module.exports = {
  ExpressionsPrettierVisitor
};
